{{/*
SPDX-FileCopyrightText: 2025 OpenCHAMI a Series of LF Projects, LLC

SPDX-License-Identifier: MIT
*/}}
// Code generated by Fabrica {{.Version}}. DO NOT EDIT.
// Template: {{.Template}}

package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/openchami/fabrica/pkg/resource"
	"github.com/openchami/fabrica/pkg/validation"
	"{{.Package}}"
	"{{.ModulePath}}/internal/storage"
)

// Get{{.Name}}sFlat returns all {{.Name}} resources in flat format
func Get{{.Name}}sFlat(w http.ResponseWriter, r *http.Request) {
	envelopeList, err := storage.LoadAll{{.StorageName}}s(r.Context())
	if err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to load {{.PluralName}}: %w", err))
		return
	}

	flatList := make([]*{{.Name}}Flat, len(envelopeList))
	for i, item := range envelopeList {
		flatList[i] = {{.Name}}ToFlat(item)
	}
	
	respondJSON(w, http.StatusOK, flatList)
}

// Get{{.Name}}Flat returns a specific {{.Name}} resource in flat format
func Get{{.Name}}Flat(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("UID is required"))
		return
	}

	item, err := storage.Load{{.StorageName}}(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("{{.Name}} not found: %w", err))
		return
	}

	respondJSON(w, http.StatusOK, {{.Name}}ToFlat(item))
}

// Create{{.Name}}Flat creates a new {{.Name}} from a flat JSON body
func Create{{.Name}}Flat(w http.ResponseWriter, r *http.Request) {
	var flatReq {{.Name}}Flat
	if err := json.NewDecoder(r.Body).Decode(&flatReq); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("invalid request body: %w", err))
		return
	}

	// Convert to Envelope (Status is ignored here)
	envelope := {{.Name}}FromFlat(&flatReq)

	// Generate UID if not provided
	if envelope.Metadata.UID == "" {
		uid, err := resource.GenerateUIDForResource("{{.Name}}")
		if err != nil {
			respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to generate UID: %w", err))
			return
		}
		envelope.Metadata.UID = uid
	}

	// Timestamps
	now := time.Now()
	envelope.Metadata.CreatedAt = now
	envelope.Metadata.UpdatedAt = now

	// Validate
	if err := validation.ValidateResource(envelope); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("validation failed: %w", err))
		return
	}

	// Save
	if err := storage.Save{{.StorageName}}(r.Context(), envelope); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save: %w", err))
		return
	}

	respondJSON(w, http.StatusCreated, {{.Name}}ToFlat(envelope))
}

// Update{{.Name}}Flat updates an existing {{.Name}} from a flat JSON body
func Update{{.Name}}Flat(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("UID is required"))
		return
	}

	// 1. Load existing to preserve Status and immutable Metadata
	existing, err := storage.Load{{.StorageName}}(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("{{.Name}} not found: %w", err))
		return
	}

	// 2. Parse input
	var flatReq {{.Name}}Flat
	if err := json.NewDecoder(r.Body).Decode(&flatReq); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("invalid request body: %w", err))
		return
	}

	// 3. Update Spec fields (Status is IGNORED from input)
	incoming := {{.Name}}FromFlat(&flatReq)
	existing.Spec = incoming.Spec

	// 4. Update allowed Metadata
	if incoming.Metadata.Name != "" {
		existing.Metadata.Name = incoming.Metadata.Name
	}
	if incoming.Metadata.Labels != nil {
		existing.Metadata.Labels = incoming.Metadata.Labels
	}
	if incoming.Metadata.Annotations != nil {
		existing.Metadata.Annotations = incoming.Metadata.Annotations
	}

	// 5. Touch and Save
	existing.Touch()

	if err := validation.ValidateResource(existing); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("validation failed: %w", err))
		return
	}

	if err := storage.Save{{.StorageName}}(r.Context(), existing); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save: %w", err))
		return
	}

	respondJSON(w, http.StatusOK, {{.Name}}ToFlat(existing))
}