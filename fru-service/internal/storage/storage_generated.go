// Code generated by Fabrica. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file provides storage functions using Ent as the backend.
// The functions maintain the same interface as file storage for compatibility.

package storage

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/example/fru-service/internal/storage/ent"
	entresource "github.com/example/fru-service/internal/storage/ent/resource"

	fru "github.com/example/fru-service/pkg/resources/fru"

	device "github.com/example/fru-service/pkg/resources/device"

	location "github.com/example/fru-service/pkg/resources/location"

	connection "github.com/example/fru-service/pkg/resources/connection"
)

// ErrNotFound indicates that a resource was not found
var ErrNotFound = errors.New("resource not found")

// Ent client (initialized in main.go)
var entClient *ent.Client

// SetEntClient sets the Ent client for storage operations
func SetEntClient(client *ent.Client) {
	entClient = client
}

// LoadAllFRUs loads all FRU resources from Ent storage
func LoadAllFRUs(ctx context.Context) ([]*fru.FRU, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query all resources of this kind
	entResources, err := entClient.Resource.Query().
		Where(entresource.KindEQ("FRU")).
		WithLabels().
		WithAnnotations().
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load FRU resources: %w", err)
	}

	// Convert to Fabrica resources
	var resources []*fru.FRU
	for _, entResource := range entResources {
		fabricaResource, err := FromEntResource(ctx, entResource)
		if err != nil {
			// Log error but continue with other resources
			continue
		}
		resources = append(resources, fabricaResource.(*fru.FRU))
	}

	return resources, nil
}

// LoadFRU loads a single FRU resource by UID from Ent storage
func LoadFRU(ctx context.Context, uid string) (*fru.FRU, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query by UID and kind
	entResource, err := entClient.Resource.Query().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("FRU"),
		).
		WithLabels().
		WithAnnotations().
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("failed to load FRU %s: %w", uid, err)
	}

	// Convert to Fabrica resource
	fabricaResource, err := FromEntResource(ctx, entResource)
	if err != nil {
		return nil, err
	}

	return fabricaResource.(*fru.FRU), nil
}

// SaveFRU saves a FRU resource to Ent storage
func SaveFRU(ctx context.Context, resource *fru.FRU) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Convert to Ent entity
	createBuilder, labels, annotations, err := ToEntResource(resource)
	if err != nil {
		return fmt.Errorf("failed to convert FRU to ent: %w", err)
	}

	// Use upsert pattern: try to update, if not exists then create
	entResource, err := entClient.Resource.Query().
		Where(entresource.UIDEQ(resource.GetUID())).
		Only(ctx)

	if err != nil && !ent.IsNotFound(err) {
		return fmt.Errorf("failed to check FRU existence: %w", err)
	}

	var savedResource *ent.Resource
	if ent.IsNotFound(err) {
		// Create new resource
		savedResource, err = createBuilder.Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create FRU: %w", err)
		}
	} else {
		// Update existing resource
		spec, _ := json.Marshal(resource.Spec)
		status, _ := json.Marshal(resource.Status)

		savedResource, err = entClient.Resource.UpdateOne(entResource).
			SetName(resource.Metadata.Name).
			SetAPIVersion(resource.APIVersion).
			SetSpec(spec).
			SetStatus(status).
			SetUpdatedAt(time.Now()).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to update FRU: %w", err)
		}
	}

	// Save labels
	if err := saveLabels(ctx, savedResource.ID, labels); err != nil {
		return err
	}

	// Save annotations
	if err := saveAnnotations(ctx, savedResource.ID, annotations); err != nil {
		return err
	}

	return nil
}

// DeleteFRU deletes a FRU resource from Ent storage
func DeleteFRU(ctx context.Context, uid string) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Delete by UID
	deleted, err := entClient.Resource.Delete().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("FRU"),
		).
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to delete FRU %s: %w", uid, err)
	}

	if deleted == 0 {
		return ErrNotFound
	}

	return nil
}

// LoadAllDevices loads all Device resources from Ent storage
func LoadAllDevices(ctx context.Context) ([]*device.Device, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query all resources of this kind
	entResources, err := entClient.Resource.Query().
		Where(entresource.KindEQ("Device")).
		WithLabels().
		WithAnnotations().
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load Device resources: %w", err)
	}

	// Convert to Fabrica resources
	var resources []*device.Device
	for _, entResource := range entResources {
		fabricaResource, err := FromEntResource(ctx, entResource)
		if err != nil {
			// Log error but continue with other resources
			continue
		}
		resources = append(resources, fabricaResource.(*device.Device))
	}

	return resources, nil
}

// LoadDevice loads a single Device resource by UID from Ent storage
func LoadDevice(ctx context.Context, uid string) (*device.Device, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query by UID and kind
	entResource, err := entClient.Resource.Query().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("Device"),
		).
		WithLabels().
		WithAnnotations().
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("failed to load Device %s: %w", uid, err)
	}

	// Convert to Fabrica resource
	fabricaResource, err := FromEntResource(ctx, entResource)
	if err != nil {
		return nil, err
	}

	return fabricaResource.(*device.Device), nil
}

// SaveDevice saves a Device resource to Ent storage
func SaveDevice(ctx context.Context, resource *device.Device) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Convert to Ent entity
	createBuilder, labels, annotations, err := ToEntResource(resource)
	if err != nil {
		return fmt.Errorf("failed to convert Device to ent: %w", err)
	}

	// Use upsert pattern: try to update, if not exists then create
	entResource, err := entClient.Resource.Query().
		Where(entresource.UIDEQ(resource.GetUID())).
		Only(ctx)

	if err != nil && !ent.IsNotFound(err) {
		return fmt.Errorf("failed to check Device existence: %w", err)
	}

	var savedResource *ent.Resource
	if ent.IsNotFound(err) {
		// Create new resource
		savedResource, err = createBuilder.Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create Device: %w", err)
		}
	} else {
		// Update existing resource
		spec, _ := json.Marshal(resource.Spec)
		status, _ := json.Marshal(resource.Status)

		savedResource, err = entClient.Resource.UpdateOne(entResource).
			SetName(resource.Metadata.Name).
			SetAPIVersion(resource.APIVersion).
			SetSpec(spec).
			SetStatus(status).
			SetUpdatedAt(time.Now()).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to update Device: %w", err)
		}
	}

	// Save labels
	if err := saveLabels(ctx, savedResource.ID, labels); err != nil {
		return err
	}

	// Save annotations
	if err := saveAnnotations(ctx, savedResource.ID, annotations); err != nil {
		return err
	}

	return nil
}

// DeleteDevice deletes a Device resource from Ent storage
func DeleteDevice(ctx context.Context, uid string) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Delete by UID
	deleted, err := entClient.Resource.Delete().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("Device"),
		).
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to delete Device %s: %w", uid, err)
	}

	if deleted == 0 {
		return ErrNotFound
	}

	return nil
}

// LoadAllLocations loads all Location resources from Ent storage
func LoadAllLocations(ctx context.Context) ([]*location.Location, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query all resources of this kind
	entResources, err := entClient.Resource.Query().
		Where(entresource.KindEQ("Location")).
		WithLabels().
		WithAnnotations().
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load Location resources: %w", err)
	}

	// Convert to Fabrica resources
	var resources []*location.Location
	for _, entResource := range entResources {
		fabricaResource, err := FromEntResource(ctx, entResource)
		if err != nil {
			// Log error but continue with other resources
			continue
		}
		resources = append(resources, fabricaResource.(*location.Location))
	}

	return resources, nil
}

// LoadLocation loads a single Location resource by UID from Ent storage
func LoadLocation(ctx context.Context, uid string) (*location.Location, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query by UID and kind
	entResource, err := entClient.Resource.Query().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("Location"),
		).
		WithLabels().
		WithAnnotations().
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("failed to load Location %s: %w", uid, err)
	}

	// Convert to Fabrica resource
	fabricaResource, err := FromEntResource(ctx, entResource)
	if err != nil {
		return nil, err
	}

	return fabricaResource.(*location.Location), nil
}

// SaveLocation saves a Location resource to Ent storage
func SaveLocation(ctx context.Context, resource *location.Location) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Convert to Ent entity
	createBuilder, labels, annotations, err := ToEntResource(resource)
	if err != nil {
		return fmt.Errorf("failed to convert Location to ent: %w", err)
	}

	// Use upsert pattern: try to update, if not exists then create
	entResource, err := entClient.Resource.Query().
		Where(entresource.UIDEQ(resource.GetUID())).
		Only(ctx)

	if err != nil && !ent.IsNotFound(err) {
		return fmt.Errorf("failed to check Location existence: %w", err)
	}

	var savedResource *ent.Resource
	if ent.IsNotFound(err) {
		// Create new resource
		savedResource, err = createBuilder.Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create Location: %w", err)
		}
	} else {
		// Update existing resource
		spec, _ := json.Marshal(resource.Spec)
		status, _ := json.Marshal(resource.Status)

		savedResource, err = entClient.Resource.UpdateOne(entResource).
			SetName(resource.Metadata.Name).
			SetAPIVersion(resource.APIVersion).
			SetSpec(spec).
			SetStatus(status).
			SetUpdatedAt(time.Now()).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to update Location: %w", err)
		}
	}

	// Save labels
	if err := saveLabels(ctx, savedResource.ID, labels); err != nil {
		return err
	}

	// Save annotations
	if err := saveAnnotations(ctx, savedResource.ID, annotations); err != nil {
		return err
	}

	return nil
}

// DeleteLocation deletes a Location resource from Ent storage
func DeleteLocation(ctx context.Context, uid string) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Delete by UID
	deleted, err := entClient.Resource.Delete().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("Location"),
		).
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to delete Location %s: %w", uid, err)
	}

	if deleted == 0 {
		return ErrNotFound
	}

	return nil
}

// LoadAllConnections loads all Connection resources from Ent storage
func LoadAllConnections(ctx context.Context) ([]*connection.Connection, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query all resources of this kind
	entResources, err := entClient.Resource.Query().
		Where(entresource.KindEQ("Connection")).
		WithLabels().
		WithAnnotations().
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load Connection resources: %w", err)
	}

	// Convert to Fabrica resources
	var resources []*connection.Connection
	for _, entResource := range entResources {
		fabricaResource, err := FromEntResource(ctx, entResource)
		if err != nil {
			// Log error but continue with other resources
			continue
		}
		resources = append(resources, fabricaResource.(*connection.Connection))
	}

	return resources, nil
}

// LoadConnection loads a single Connection resource by UID from Ent storage
func LoadConnection(ctx context.Context, uid string) (*connection.Connection, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query by UID and kind
	entResource, err := entClient.Resource.Query().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("Connection"),
		).
		WithLabels().
		WithAnnotations().
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("failed to load Connection %s: %w", uid, err)
	}

	// Convert to Fabrica resource
	fabricaResource, err := FromEntResource(ctx, entResource)
	if err != nil {
		return nil, err
	}

	return fabricaResource.(*connection.Connection), nil
}

// SaveConnection saves a Connection resource to Ent storage
func SaveConnection(ctx context.Context, resource *connection.Connection) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Convert to Ent entity
	createBuilder, labels, annotations, err := ToEntResource(resource)
	if err != nil {
		return fmt.Errorf("failed to convert Connection to ent: %w", err)
	}

	// Use upsert pattern: try to update, if not exists then create
	entResource, err := entClient.Resource.Query().
		Where(entresource.UIDEQ(resource.GetUID())).
		Only(ctx)

	if err != nil && !ent.IsNotFound(err) {
		return fmt.Errorf("failed to check Connection existence: %w", err)
	}

	var savedResource *ent.Resource
	if ent.IsNotFound(err) {
		// Create new resource
		savedResource, err = createBuilder.Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create Connection: %w", err)
		}
	} else {
		// Update existing resource
		spec, _ := json.Marshal(resource.Spec)
		status, _ := json.Marshal(resource.Status)

		savedResource, err = entClient.Resource.UpdateOne(entResource).
			SetName(resource.Metadata.Name).
			SetAPIVersion(resource.APIVersion).
			SetSpec(spec).
			SetStatus(status).
			SetUpdatedAt(time.Now()).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to update Connection: %w", err)
		}
	}

	// Save labels
	if err := saveLabels(ctx, savedResource.ID, labels); err != nil {
		return err
	}

	// Save annotations
	if err := saveAnnotations(ctx, savedResource.ID, annotations); err != nil {
		return err
	}

	return nil
}

// DeleteConnection deletes a Connection resource from Ent storage
func DeleteConnection(ctx context.Context, uid string) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Delete by UID
	deleted, err := entClient.Resource.Delete().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("Connection"),
		).
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to delete Connection %s: %w", uid, err)
	}

	if deleted == 0 {
		return ErrNotFound
	}

	return nil
}
