// Code generated by codegen. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file provides a Cobra-based CLI for the fru_service API.
// Generated from: pkg/codegen/templates/client-cmd.go.tmpl
//
// To modify the CLI:
//  1. Edit the template file: pkg/codegen/templates/client-cmd.go.tmpl
//  2. Run 'make generate-client-cmd' to regenerate
//  3. Do NOT edit this file directly - changes will be lost
//
// Generated commands for each resource:
//   - client fru [list|get|create|update|delete]
//   - client device [list|get|create|update|delete]
//   - client location [list|get|create|update|delete]
//   - client connection [list|get|create|update|delete]
//
// Global flags (available for all commands):
//
//	--server       Server URL (env: FRU_SERVICE_SERVER)
//	--timeout      Request timeout (env: FRU_SERVICE_TIMEOUT)
//	--output, -o   Output format: table, json, yaml (env: FRU_SERVICE_OUTPUT)
//	--version, -v  API version to request: v1, v2beta1, etc. (env: FRU_SERVICE_VERSION)
//	--config       Config file path (default: ~/.fru_service-cli.yaml)
//
// Configuration sources (in order of precedence):
//  1. Command-line flags
//  2. Environment variables (FRU_SERVICE_*)
//  3. Config file (~/.fru_service-cli.yaml)
//  4. Default values
//
// Usage examples:
//
//	# List all frus (default version)
//	client fru list
//
//	# List frus with specific version
//	client fru list --version v2beta1
//
//	# Get FRU as v1
//	client fru get <uid> --version v1
//
//	# Create from JSON file with version
//	cat fru.json | client fru create --version v2beta1
//
//	# Create from inline JSON
//	client fru create --spec '{"name":"fru-01","description":"Example FRU"}'
//
//	# Use environment variables
//	export FRU_SERVICE_SERVER=https://fru_service.example.com
//	export FRU_SERVICE_VERSION=v2beta1
//	client fru list
//
// To add custom commands:
//  1. Add command definition in template after resource commands
//  2. Register it in init() function
//
// To change output formatting:
//  1. Modify printOutput function to add new formats
//  2. Update output flag validation
//
// To add authentication:
//  1. Add auth flags (--token, --username, etc.)
//  2. Modify getClient to configure auth in http.Client
//  3. Add auth headers in client package
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/example/fru-service/pkg/client"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	cfgFile    string
	serverURL  string
	timeout    time.Duration
	output     string
	apiVersion string
)

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

var rootCmd = &cobra.Command{
	Use:   filepath.Base(os.Args[0]),
	Short: "fru_service CLI",
	Long:  `A command-line interface for managing fru_service resources.`,
}

func init() {
	cobra.OnInitialize(initConfig)

	// Global flags
	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.fru_service-cli.yaml)")
	rootCmd.PersistentFlags().StringVar(&serverURL, "server", "http://localhost:8080", "fru_service server URL")
	rootCmd.PersistentFlags().DurationVar(&timeout, "timeout", 30*time.Second, "request timeout")
	rootCmd.PersistentFlags().StringVarP(&output, "output", "o", "table", "output format: table, json, yaml")
	rootCmd.PersistentFlags().StringVarP(&apiVersion, "version", "v", "", "API version to request (e.g., v1, v2beta1)")

	// Bind flags to viper
	viper.BindPFlag("server", rootCmd.PersistentFlags().Lookup("server"))
	viper.BindPFlag("timeout", rootCmd.PersistentFlags().Lookup("timeout"))
	viper.BindPFlag("output", rootCmd.PersistentFlags().Lookup("output"))
	viper.BindPFlag("version", rootCmd.PersistentFlags().Lookup("version"))

	// Environment variable support
	viper.SetEnvPrefix("FRU_SERVICE")
	viper.AutomaticEnv()

	// Add resource commands
	rootCmd.AddCommand(fruCmd)
	rootCmd.AddCommand(deviceCmd)
	rootCmd.AddCommand(locationCmd)
	rootCmd.AddCommand(connectionCmd)

}

func initConfig() {
	if cfgFile != "" {
		viper.SetConfigFile(cfgFile)
	} else {
		home, err := os.UserHomeDir()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: %v\n", err)
			return
		}

		viper.AddConfigPath(home)
		viper.SetConfigType("yaml")
		viper.SetConfigName(".fru_service-cli")
	}

	if err := viper.ReadInConfig(); err == nil {
		fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
	}
}

func getClient() (*client.Client, error) {
	serverURL := viper.GetString("server")
	c, err := client.NewClient(serverURL, nil)
	if err != nil {
		return nil, err
	}

	// Apply version if specified
	version := viper.GetString("version")
	if version != "" {
		c = c.WithVersion(version)
	}

	return c, nil
}

func printOutput(data interface{}) error {
	switch output {
	case "json":
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)
	case "yaml":
		// TODO: Add YAML support if needed
		return fmt.Errorf("YAML output not yet implemented")
	case "table":
		// Simple table output
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)
	default:
		return fmt.Errorf("unknown output format: %s", output)
	}
}

// FRU commands
var fruCmd = &cobra.Command{
	Use:   "fru",
	Short: "Manage frus",
	Long:  `Create, read, update, and delete frus.`,
}

var fruListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all frus",
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		items, err := c.GetFRUs(ctx)
		if err != nil {
			return fmt.Errorf("failed to list frus: %w", err)
		}

		return printOutput(items)
	},
}

var fruGetCmd = &cobra.Command{
	Use:   "get [uid]",
	Short: "Get a FRU by UID",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.GetFRU(ctx, args[0])
		if err != nil {
			return fmt.Errorf("failed to get FRU: %w", err)
		}

		return printOutput(item)
	},
}

var fruCreateCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new FRU",
	Long: `Create a new FRU.

Examples:
  # Create from stdin
  echo '{"fruType": "example-value", "serialNumber": "example-value", "partNumber": "example-value", "manufacturer": "example-value", "model": "example-value", "location": "{}", "parentUID": "example-value", "childrenUIDs": ["["item1","item2"]"], "redfishPath": "example-value", "properties": {"{"key":"value"}": "value"}}' | client fru create

  # Create with --spec flag
  client fru create --spec '{"fruType": "example-value", "serialNumber": "example-value", "partNumber": "example-value", "manufacturer": "example-value", "model": "example-value", "location": "{}", "parentUID": "example-value", "childrenUIDs": ["["item1","item2"]"], "redfishPath": "example-value", "properties": {"{"key":"value"}": "value"}}'

Spec fields:
  fruType (string)
  serialNumber (string)
  partNumber (string)
  manufacturer (string)
  model (string)
  location (fru.FRULocation)
  parentUID (string)
  childrenUIDs ([]string)
  redfishPath (string)
  properties (map[string]string)
`,
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.CreateFRURequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.CreateFRU(ctx, req)
		if err != nil {
			return fmt.Errorf("failed to create FRU: %w", err)
		}

		return printOutput(item)
	},
}

var fruUpdateCmd = &cobra.Command{
	Use:   "update [uid]",
	Short: "Update an existing FRU",
	Long: `Update an existing FRU.

Examples:
  # Update from stdin
  echo '{"fruType": "example-value", "serialNumber": "example-value", "partNumber": "example-value", "manufacturer": "example-value", "model": "example-value", "location": "{}", "parentUID": "example-value", "childrenUIDs": ["["item1","item2"]"], "redfishPath": "example-value", "properties": {"{"key":"value"}": "value"}}' | client fru update <uid>

  # Update with --spec flag
  client fru update <uid> --spec '{"fruType": "example-value", "serialNumber": "example-value", "partNumber": "example-value", "manufacturer": "example-value", "model": "example-value", "location": "{}", "parentUID": "example-value", "childrenUIDs": ["["item1","item2"]"], "redfishPath": "example-value", "properties": {"{"key":"value"}": "value"}}'

Spec fields:
  fruType (string)
  serialNumber (string)
  partNumber (string)
  manufacturer (string)
  model (string)
  location (fru.FRULocation)
  parentUID (string)
  childrenUIDs ([]string)
  redfishPath (string)
  properties (map[string]string)
`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.UpdateFRURequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.UpdateFRU(ctx, args[0], req)
		if err != nil {
			return fmt.Errorf("failed to update FRU: %w", err)
		}

		return printOutput(item)
	},
}

var fruDeleteCmd = &cobra.Command{
	Use:   "delete [uid]",
	Short: "Delete a FRU",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		if err := c.DeleteFRU(ctx, args[0]); err != nil {
			return fmt.Errorf("failed to delete FRU: %w", err)
		}

		fmt.Printf("FRU %s deleted successfully\n", args[0])
		return nil
	},
}

func init() {
	fruCmd.AddCommand(fruListCmd)
	fruCmd.AddCommand(fruGetCmd)
	fruCmd.AddCommand(fruCreateCmd)
	fruCmd.AddCommand(fruUpdateCmd)
	fruCmd.AddCommand(fruDeleteCmd)

	// Add spec flag for create and update commands
	fruCreateCmd.Flags().String("spec", "", "FRU specification in JSON format")
	fruUpdateCmd.Flags().String("spec", "", "FRU specification in JSON format")
}

// Device commands
var deviceCmd = &cobra.Command{
	Use:   "device",
	Short: "Manage devices",
	Long:  `Create, read, update, and delete devices.`,
}

var deviceListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all devices",
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		items, err := c.GetDevices(ctx)
		if err != nil {
			return fmt.Errorf("failed to list devices: %w", err)
		}

		return printOutput(items)
	},
}

var deviceGetCmd = &cobra.Command{
	Use:   "get [uid]",
	Short: "Get a Device by UID",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.GetDevice(ctx, args[0])
		if err != nil {
			return fmt.Errorf("failed to get Device: %w", err)
		}

		return printOutput(item)
	},
}

var deviceCreateCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new Device",
	Long: `Create a new Device.

Examples:
  # Create from stdin
  echo '{"componentType": "example-value", "manufacturer": "example-value", "partNumber": "example-value", "serialNumber": "example-value", "locationId": "DataCenter A"}' | client device create

  # Create with --spec flag
  client device create --spec '{"componentType": "example-value", "manufacturer": "example-value", "partNumber": "example-value", "serialNumber": "example-value", "locationId": "DataCenter A"}'

Spec fields:
  componentType (string) [required]
  manufacturer (string)
  partNumber (string)
  serialNumber (string)
  locationId (string)
`,
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.CreateDeviceRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.CreateDevice(ctx, req)
		if err != nil {
			return fmt.Errorf("failed to create Device: %w", err)
		}

		return printOutput(item)
	},
}

var deviceUpdateCmd = &cobra.Command{
	Use:   "update [uid]",
	Short: "Update an existing Device",
	Long: `Update an existing Device.

Examples:
  # Update from stdin
  echo '{"componentType": "example-value", "manufacturer": "example-value", "partNumber": "example-value", "serialNumber": "example-value", "locationId": "DataCenter A"}' | client device update <uid>

  # Update with --spec flag
  client device update <uid> --spec '{"componentType": "example-value", "manufacturer": "example-value", "partNumber": "example-value", "serialNumber": "example-value", "locationId": "DataCenter A"}'

Spec fields:
  componentType (string) [required]
  manufacturer (string)
  partNumber (string)
  serialNumber (string)
  locationId (string)
`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.UpdateDeviceRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.UpdateDevice(ctx, args[0], req)
		if err != nil {
			return fmt.Errorf("failed to update Device: %w", err)
		}

		return printOutput(item)
	},
}

var deviceDeleteCmd = &cobra.Command{
	Use:   "delete [uid]",
	Short: "Delete a Device",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		if err := c.DeleteDevice(ctx, args[0]); err != nil {
			return fmt.Errorf("failed to delete Device: %w", err)
		}

		fmt.Printf("Device %s deleted successfully\n", args[0])
		return nil
	},
}

func init() {
	deviceCmd.AddCommand(deviceListCmd)
	deviceCmd.AddCommand(deviceGetCmd)
	deviceCmd.AddCommand(deviceCreateCmd)
	deviceCmd.AddCommand(deviceUpdateCmd)
	deviceCmd.AddCommand(deviceDeleteCmd)

	// Add spec flag for create and update commands
	deviceCreateCmd.Flags().String("spec", "", "Device specification in JSON format")
	deviceUpdateCmd.Flags().String("spec", "", "Device specification in JSON format")
}

// Location commands
var locationCmd = &cobra.Command{
	Use:   "location",
	Short: "Manage locations",
	Long:  `Create, read, update, and delete locations.`,
}

var locationListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all locations",
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		items, err := c.GetLocations(ctx)
		if err != nil {
			return fmt.Errorf("failed to list locations: %w", err)
		}

		return printOutput(items)
	},
}

var locationGetCmd = &cobra.Command{
	Use:   "get [uid]",
	Short: "Get a Location by UID",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.GetLocation(ctx, args[0])
		if err != nil {
			return fmt.Errorf("failed to get Location: %w", err)
		}

		return printOutput(item)
	},
}

var locationCreateCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new Location",
	Long: `Create a new Location.

Examples:
  # Create from stdin
  echo '{"parentLocationId": "DataCenter A", "locationType": "DataCenter A"}' | client location create

  # Create with --spec flag
  client location create --spec '{"parentLocationId": "DataCenter A", "locationType": "DataCenter A"}'

Spec fields:
  parentLocationId (string)
  locationType (string)
`,
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.CreateLocationRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.CreateLocation(ctx, req)
		if err != nil {
			return fmt.Errorf("failed to create Location: %w", err)
		}

		return printOutput(item)
	},
}

var locationUpdateCmd = &cobra.Command{
	Use:   "update [uid]",
	Short: "Update an existing Location",
	Long: `Update an existing Location.

Examples:
  # Update from stdin
  echo '{"parentLocationId": "DataCenter A", "locationType": "DataCenter A"}' | client location update <uid>

  # Update with --spec flag
  client location update <uid> --spec '{"parentLocationId": "DataCenter A", "locationType": "DataCenter A"}'

Spec fields:
  parentLocationId (string)
  locationType (string)
`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.UpdateLocationRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.UpdateLocation(ctx, args[0], req)
		if err != nil {
			return fmt.Errorf("failed to update Location: %w", err)
		}

		return printOutput(item)
	},
}

var locationDeleteCmd = &cobra.Command{
	Use:   "delete [uid]",
	Short: "Delete a Location",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		if err := c.DeleteLocation(ctx, args[0]); err != nil {
			return fmt.Errorf("failed to delete Location: %w", err)
		}

		fmt.Printf("Location %s deleted successfully\n", args[0])
		return nil
	},
}

func init() {
	locationCmd.AddCommand(locationListCmd)
	locationCmd.AddCommand(locationGetCmd)
	locationCmd.AddCommand(locationCreateCmd)
	locationCmd.AddCommand(locationUpdateCmd)
	locationCmd.AddCommand(locationDeleteCmd)

	// Add spec flag for create and update commands
	locationCreateCmd.Flags().String("spec", "", "Location specification in JSON format")
	locationUpdateCmd.Flags().String("spec", "", "Location specification in JSON format")
}

// Connection commands
var connectionCmd = &cobra.Command{
	Use:   "connection",
	Short: "Manage connections",
	Long:  `Create, read, update, and delete connections.`,
}

var connectionListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all connections",
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		items, err := c.GetConnections(ctx)
		if err != nil {
			return fmt.Errorf("failed to list connections: %w", err)
		}

		return printOutput(items)
	},
}

var connectionGetCmd = &cobra.Command{
	Use:   "get [uid]",
	Short: "Get a Connection by UID",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.GetConnection(ctx, args[0])
		if err != nil {
			return fmt.Errorf("failed to get Connection: %w", err)
		}

		return printOutput(item)
	},
}

var connectionCreateCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new Connection",
	Long: `Create a new Connection.

Examples:
  # Create from stdin
  echo '{"connectionType": "example-value", "mediumId": "example-value", "endpointA": {}, "endpointB": {}}' | client connection create

  # Create with --spec flag
  client connection create --spec '{"connectionType": "example-value", "mediumId": "example-value", "endpointA": {}, "endpointB": {}}'

Spec fields:
  connectionType (string) [required]
  mediumId (string)
  endpointA (connection.Endpoint) [required]
  endpointB (connection.Endpoint) [required]
`,
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.CreateConnectionRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.CreateConnection(ctx, req)
		if err != nil {
			return fmt.Errorf("failed to create Connection: %w", err)
		}

		return printOutput(item)
	},
}

var connectionUpdateCmd = &cobra.Command{
	Use:   "update [uid]",
	Short: "Update an existing Connection",
	Long: `Update an existing Connection.

Examples:
  # Update from stdin
  echo '{"connectionType": "example-value", "mediumId": "example-value", "endpointA": {}, "endpointB": {}}' | client connection update <uid>

  # Update with --spec flag
  client connection update <uid> --spec '{"connectionType": "example-value", "mediumId": "example-value", "endpointA": {}, "endpointB": {}}'

Spec fields:
  connectionType (string) [required]
  mediumId (string)
  endpointA (connection.Endpoint) [required]
  endpointB (connection.Endpoint) [required]
`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.UpdateConnectionRequest

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.UpdateConnection(ctx, args[0], req)
		if err != nil {
			return fmt.Errorf("failed to update Connection: %w", err)
		}

		return printOutput(item)
	},
}

var connectionDeleteCmd = &cobra.Command{
	Use:   "delete [uid]",
	Short: "Delete a Connection",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		if err := c.DeleteConnection(ctx, args[0]); err != nil {
			return fmt.Errorf("failed to delete Connection: %w", err)
		}

		fmt.Printf("Connection %s deleted successfully\n", args[0])
		return nil
	},
}

func init() {
	connectionCmd.AddCommand(connectionListCmd)
	connectionCmd.AddCommand(connectionGetCmd)
	connectionCmd.AddCommand(connectionCreateCmd)
	connectionCmd.AddCommand(connectionUpdateCmd)
	connectionCmd.AddCommand(connectionDeleteCmd)

	// Add spec flag for create and update commands
	connectionCreateCmd.Flags().String("spec", "", "Connection specification in JSON format")
	connectionUpdateCmd.Flags().String("spec", "", "Connection specification in JSON format")
}
